<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@ViewData["Title"]</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/js/initializeChart.js"></script>
    <script src="/js/handleTelemetry.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #0d0d0d;
            color: #f9f9f9;
            margin: 0;
            padding: 0;
            height: 100vh !important;
        }

        .swal2-height-auto {
            height: 100vh !important;
        }

        .flex-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
        }

        .top-row, .bottom-row {
            display: flex;
            width: 100%;
        }
        .top-row {
            height: 58vh;
        }

        .bottom-row {
            height: 30vh;
        }

        .telemetry-section {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 16px;
            overflow: hidden;
            border: 1px solid #333;
        }

        .top-row .telemetry-section:first-child {
            flex: 1 1 20%;
        }

        .top-row .telemetry-section:last-child {
            flex: 1 1 80%;
            position: relative;
            padding-right: 220px; /* Reserve space for sidebar */
        }

        .telemetry-section h2 {
            font-size: 3rem;
            color: white;
        }

        .telem-header{
            font-size:3rem;
            color:white;
        }

        .content {
            flex-grow: 1;
            overflow-y: auto;
            margin-top: 10px;
            padding-right: 5px;
        }

        .button-container {
            border-top: 2px solid #ffffff30;
            padding-top: 10px;
        }

        .iframe-section {
            flex: 1;
            border: 1px solid #333;
        }

        .swal2-container {
            overflow-y: hidden !important;
        }

        .status-nominal {
            color: greenyellow;
        }

        /* Chart container styling */
        #charts-wrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .chart-container {
            width: calc(50% - 10px);
            box-sizing: border-box;
            background-color: black;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 10px;
            height:fit-content;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
        }

        .popup-content {
            background-color: #333;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            text-align: center;
        }

            .popup-content input[type="range"] {
                width: 100%;
            }

            .popup-content button {
                margin-top: 10px;
            }

        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #1f1f1f;
            padding: 4px 4px;
            border-bottom: 1px solid #333;
        }

            .navbar h2 {
                font-size: 1.25rem;
                font-weight: 600;
                color: #fff;
            }

            .navbar .comms-state {
                font-size: 1rem;
                color: #bbbbbb;
            }

            .navbar .button-group {
                display: flex;
                gap: 12px;
            }

            .navbar button {
                background-color: #4c6ef5;
                border-radius: 6px;
                padding: 8px 16px;
                color: white;
                text-sm;
                transition: background-color 0.3s;
            }

                .navbar button:hover {
                    background-color: #3b5ac2;
                }

        .input-container input {
            border-radius: 6px;
            padding: 8px;
            color: black;
            width: 100px;
        }

        /* Tooltip styles for the telemetry rate input */
        .input-tooltip {
            display: none;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 5px;
            border-radius: 4px;
            position: absolute;
            top: 120%;
            left: 0;
            z-index: 10;
        }

        .input-container:hover .input-tooltip {
            display: block;
        }

        .input-field{
            color:black;
        }

    </style>
</head>

<body style="height: 100vh !important;">
 
    <div class="flex-container mt-3">
        <nav class="navbar h-1/6" id="comms-section" style="height:6%">
            <div class="border-none" style="border:none">
                <h1 class="text-3xl">COMMS</h1>
            </div>
            <div class="button-group">
                <div class="input-container relative">
                    <input type="number" min="1" max="60" id="telemRate" placeholder="Rate (S)" class="text-sm text-center rounded-lg text-black" />
                    <div class="input-tooltip">Set Telemetry Rate</div>
                </div>
                <button id="telemRateBtn" class="bg-blue-600 hover:bg-blue-700 text-sm p-1 rounded text-white">CHANGE TELEMETRY RATE</button>
            </div>
        </nav>
        <div class="w-full h-3/6 flex">
            <div class="telemetry-section w-1/2 relative flex flex-wrap" id="tcs-section">
                <!-- Main ADCS Content -->
                <div class="p-4 flex flex-col space-y-4 w-10/12 overflow-y-auto">
                    <div class="flex items-start justify-between w-full">
                        <h2 class="text-3xl" id="tcsState">TCS</h2>
                    </div>
                    <hr class="my-4 border-gray-700">
                    <!-- Chart wrapper with scrollable content -->
                    <div id="tcs-charts-wrapper" class="flex flex-wrap gap-1 overflow-y-auto">
                        <!-- Placeholder for charts -->
                    </div>
                </div>
                <!-- Sidebar for ADCS Buttons -->
                <div id="tcs-buttons" class="side w-2/12 bg-black overflow-y-auto border-l border-gray-600 flex flex-col space-y-1 text-sm">
                    Initializing
                    <!-- Additional buttons can be added here -->
                </div>
            </div>
            <div class="telemetry-section w-1/2 relative flex flex-wrap" id="eps-section">
                <!-- Main ADCS Content -->
                <div class="p-4 flex flex-col space-y-4 w-10/12 overflow-y-auto">
                    <div class="flex items-start justify-between w-full">
                        <h2 class="text-3xl" id="epsState">ADCS</h2>
                        <div class="flex space-x-2">
                            <button id="epsON" class="bg-green-900 hover:bg-green-700 text-white text-sm p-2 rounded">TURN EPS ON</button>
                            <button id="epsOFF" class="bg-red-900 hover:bg-red-700 text-white text-sm p-2 rounded">TURN EPS OFF</button>
                        </div>
                    </div>
                    <hr class="my-4 border-gray-700">
                    <!-- Chart wrapper with scrollable content -->
                    <div id="eps-charts-wrapper" class="flex flex-wrap gap-1 overflow-y-auto">
                        <!-- Placeholder for charts -->
                    </div>
                </div>
                <!-- Sidebar for ADCS Buttons -->
                <div id="eps-buttons" class="side w-2/12 bg-black overflow-y-auto border-l border-gray-600 flex flex-col space-y-1 text-sm">
                    Initializing
                    <!-- Additional buttons can be added here -->
                </div>
            </div>
        </div>

        <div class="w-full h-2/6 flex" style="height:44%">
            <div class="telemetry-section w-2/3 relative flex flex-wrap" id="adcs-section">
                <!-- Main ADCS Content -->
                <div class="p-4 flex flex-col space-y-4 w-10/12 overflow-y-auto">
                    <div class="flex items-start justify-between w-full">
                        <h2 class="text-3xl" id="adcsState">ADCS</h2>
                        <div class="flex space-x-2 w-6/12">
                            <button id="adcsON" class="bg-green-900 hover:bg-green-700 text-white text-sm p-2 rounded">TURN ADCS ON</button>
                            <button id="adcsOFF" class="bg-red-900 hover:bg-red-700 text-white text-sm p-2 rounded">TURN ADCS OFF</button>
                            <button id="actuateMotorBtn" class="bg-purple-900 hover:bg-purple-700 text-white p-2 rounded">ACTUATE MOTOR</button>
                            <button id="acdsTelemetry" class="bg-purple-900 hover:bg-purple-600 text-white text-sm py-2 px-6 rounded">GET ACDS TELEMETRY</button>
                            <button id="toggleReal" class="bg-purple-800 hover:bg-purple-500 text-white text-sm p-2 rounded">Toggle Real Telemetry</button>
                        </div>
                    </div>
                    <hr class="my-4 border-gray-700">
                    <!-- Chart wrapper with scrollable content -->
                    <div id="adcs-charts-wrapper" class="flex flex-wrap gap-1 overflow-y-auto">
                        <!-- Placeholder for charts -->
                    </div>
                </div>
                <!-- Sidebar for ADCS Buttons -->
                <div id="adcs-buttons" class="side w-2/12 bg-black overflow-y-auto border-l border-gray-600 flex flex-col space-y-1 text-sm">
                    Initializing
                    <!-- Additional buttons can be added here -->
                </div>
            </div>
            <div class="iframe-section w-1/3">
                <iframe src="/static/html" class="w-full h-full border-0" title="Example HTML File"></iframe>
            </div>
        </div>
    </div>
    <div id="popupOverlay" class="popup-overlay">
        <div class="popup-content">
            <h2>Motor Actuation Strength/Direction</h2>
            <input type="range" id="motorActuation" class="slider" min="-5" max="5" value="0" />
            <div class="flex justify-center mt-4 space-x-6">
                <button id="motorActuate" class="bg-purple-900 hover:bg-purple-700 text-white p-1 rounded">ACTUATE MOTOR</button>
                <span id="motorActuationValue" class="text-lg">0</span>
            </div>
            <div class="mt-4">
                <button id="closePopup" class="bg-red-600 hover:bg-red-700 text-white p-2 rounded">Close</button>
            </div>
        </div>
    </div>
    <div id="chartConfigOverlay" class="popup-overlay">
        <div class="popup-content">
            <h2>Configure Chart Parameters</h2>
            <label>Min Reading:</label>
            <input type="number" id="chartMinReading" class="input-field" placeholder="e.g., 0" />
            <label>Max Reading:</label>
            <input type="number" id="chartMaxReading" class="input-field" placeholder="e.g., 100" />
            <label>Nominal Min:</label>
            <input type="number" id="chartNominalMin" class="input-field" placeholder="e.g., 20" />
            <label>Nominal Max:</label>
            <input type="number" id="chartNominalMax" class="input-field" placeholder="e.g., 80" />
            <label>Color (RGB):</label>
            <input type="number" id="chartColorR" class="input-field" placeholder="Red (0-255)" />
            <input type="number" id="chartColorG" class="input-field" placeholder="Green (0-255)" />
            <input type="number" id="chartColorB" class="input-field" placeholder="Blue (0-255)" />
            <div class="mt-4 flex justify-center space-x-4">
                <button id="submitChartConfig" class="bg-blue-600 text-white p-2 rounded">Submit</button>
                <button id="closeChartConfig" class="bg-red-600 text-white p-2 rounded">Close</button>
            </div>
        </div>
    </div>
        <script>

        const chartConfigOverlay = document.getElementById("chartConfigOverlay");
        const submitChartConfig = document.getElementById("submitChartConfig");
        const closeChartConfig = document.getElementById("closeChartConfig");
            let currentChartSection = null;
        let currentSensorIdForChart = null;
        closeChartConfig.addEventListener("click", () => {
            chartConfigOverlay.style.display = "none";
        });
        submitChartConfig.addEventListener("click", () => {
            const minReading = parseFloat(document.getElementById("chartMinReading").value);
            const maxReading = parseFloat(document.getElementById("chartMaxReading").value);
            const nominalMin = parseFloat(document.getElementById("chartNominalMin").value);
            const nominalMax = parseFloat(document.getElementById("chartNominalMax").value);
            const colorR = parseInt(document.getElementById("chartColorR").value);
            const colorG = parseInt(document.getElementById("chartColorG").value);
            const colorB = parseInt(document.getElementById("chartColorB").value);
            const chartColor = `rgba(${colorR}, ${colorG}, ${colorB}, 0.6)`;



            // Check if a chart already exists for this sensor and remove it if necessary
            if (charts[currentSensorIdForChart]) {
                console.log(`Removing existing chart for ${currentSensorIdForChart}.`);
                charts[currentSensorIdForChart].destroy();
                delete charts[currentSensorIdForChart];
                document.getElementById(currentSensorIdForChart).parentElement.remove();
            }

            // Initialize the chart for the selected sensor with the configured values
            charts[currentSensorIdForChart] = initializeChart(
                currentChartSection,
                currentSensorIdForChart,
                `${currentSensorIdForChart}`,
                chartColor,
                minReading,
                maxReading,
                nominalMin,
                nominalMax
            );

            // Hide the overlay after submission
            chartConfigOverlay.style.display = "none";
        });

        const actuationButton = document.getElementById("actuateMotorBtn");
        const popupOverlay = document.getElementById("popupOverlay");
        const closePopupButton = document.getElementById("closePopup");
        actuationButton.addEventListener("click", () => {
            popupOverlay.style.display = "flex";
        });

        // Close the popup when the close button is clicked
        closePopupButton.addEventListener("click", () => {
            popupOverlay.style.display = "none";
        });
       

        // Function to create buttons dynamically for each button group
        function createButtons(sensorsConfig) {
            const commsSection = document.getElementById('chart-generator-buttons');

            // Clear any existing buttons
            commsSection.innerHTML = '';

            // Iterate through the buttons in the configuration and create button elements
            Object.keys(sensorsConfig).forEach(buttonName => {
                const button = document.createElement('button');
                button.innerText = buttonName;
                button.classList.add('sensor-button'); // You can style these with CSS
                button.onclick = () => handleButtonClick(buttonName, sensorsConfig[buttonName]);
                commsSection.appendChild(button);
            });
        }

        // Handler for button click: update charts based on the selected button's sensors
        function handleButtonClick(buttonName, sensors) {
            sensors.forEach(sensor => {
                // Extract the sensor details from the sensor object
                const { sensor: sensorId, minVal, maxVal, nominalMin, nominalMax, r, g, b } = sensor;

                // Check if a chart for this sensor already exists
                if (charts[sensorId]) {
                    console.log(`Removing existing chart for ${sensorId}.`);
                    charts[sensorId].destroy();  // Destroy the existing chart instance
                    console.log(document.getElementById(sensorId))
                    delete charts[sensorId];     // Remove it from the charts object
                    document.getElementById(sensorId).parentElement.remove(); // Remove the chart element from the DOM
                }

                // Check if the sensor data is valid before creating the chart
                else if (sensorId && minVal !== undefined && maxVal !== undefined) {
                    // Create a new chart for the sensor
                    charts[sensorId] = initializeChart(
                        sensorId,               // Chart container id
                        sensorId + " Value",    // Chart title
                        `rgba(${r}, ${g}, ${b}, 0.6)`, // Chart color
                        minVal,                 // Minimum value
                        maxVal,                 // Maximum value
                        nominalMin,             // Nominal minimum value
                        nominalMax              // Nominal maximum value
                    );
                } else {
                    console.error(`Invalid sensor data for ${sensorId}. Cannot create chart.`);
                }
            });
        }



            function parseTelemetry(telemetry) {
                const telemetryLines = telemetry.split('\n');
                // Error Check
                const errorCheck = telemetryLines.find(line => line.includes('Error opening COM port') || line.includes('COM PORT DISCONNECTED'));
                if (errorCheck) {
                    handleTelemetryError('Error: COM port disconnected.');
                    return;
                }

                // Clear error state if telemetry is good
                removeErrorStyles();
                var commsLine;
                var comms;
                if(real){
                comms = telemetryLines.filter(line => line.includes('I:'));
                    commsLine = comms[0];
                }
                else{
                 comms = telemetryLines.filter(line => line.includes('I:'));
                 commsLine = comms;
                }
                // Comms Section

                if (commsLine) {
                    const pwrValue = commsLine.includes('Pwr=1');
                const adcsValue = commsLine.includes('ADCS=1') || commsLine.includes('ADS=1');
                    // Update COMMS section
                    let pwrStatusClass = pwrValue ? 'status-nominal' : 'status-bad';
                let commsStatusGlow = pwrValue
                    ? (document.getElementById('comms-section').classList.remove('error'), document.getElementById('comms-section').classList.add('nominal'))
                    : (document.getElementById('comms-section').classList.add('error'), document.getElementById('comms-section').classList.remove('nominal'));
                document.getElementById('epsState').innerHTML = `<p class="${pwrStatusClass}">EPS: ${pwrValue ? 'Nominal' : 'Error'}</p>`;

                let pwrStatusGlow = pwrValue
                    ? (document.getElementById('eps-section').classList.remove('error'), document.getElementById('eps-section').classList.add('nominal'))
                    : (document.getElementById('eps-section').classList.add('error'), document.getElementById('eps-section').classList.remove('nominal'));                    // Update ADCS section
                    let adcsStatusClass = adcsValue ? 'status-nominal' : 'status-bad';
                    document.getElementById('adcsState').innerHTML = `<p class="${adcsStatusClass}">ADCS: ${adcsValue ? 'Nominal' : 'Error'}</p>`;
                let adcsStatusGlow = adcsValue
                    ? (document.getElementById('adcs-section').classList.remove('error'), document.getElementById('adcs-section').classList.add('nominal'))
                    : (document.getElementById('adcs-section').classList.add('error'), document.getElementById('adcs-section').classList.remove('nominal'));
                document.getElementById('tcsState').innerHTML = `<p class="${adcsStatusClass}">TCS: ${adcsValue ? 'Nominal' : 'Error'}</p>`;

                let tcsStatusGlow = adcsValue
                    ? (document.getElementById('tcs-section').classList.remove('error'), document.getElementById('tcs-section').classList.add('nominal'))
                    : (document.getElementById('tcs-section').classList.add('error'), document.getElementById('tcs-section').classList.remove('nominal'));
                    if (!pwrValue) {
                    var audio = new Audio('./err-beep.mp3');
                    audio.play();

                    }
                    if (!adcsValue) {
                    var audio = new Audio('./err-beep.mp3');
                    audio.play();

                    }
                    // EPS Section
                    const epsData = telemetryLines.filter(line => line.includes('P:'))[0];



                var adcsData = telemetryLines.filter(line => line.includes('A:'))[0];
                // Check for specific telemetry messages in ADCS
                if (adcsData.includes("check ADS board connection")) {
                    adcsData = "No telemetry from ADCS board. Ensure proper connection, power, and enabled telemetry.";
                } else if (epsData && adcsData.length > 0) {

                    // Object to hold dynamically extracted telemetry data
                    const telemetryData = {};

                    // Loop through chart keys to dynamically extract data from epsData and adcsData
                    Object.keys(charts).forEach(key => {
                        let variable = null;

                        // Try to extract value from epsData first
                        if (epsData.includes(key + '=')) {
                            variable = epsData.split(key + '=')[1].split(' ')[0].replace(',','');
                        }
                        // If not found, try to extract from adcsData
                        else if (adcsData.includes(key + '=')) {
                            variable = adcsData.split(key + '=')[1].split(' ')[0].replace(',', '');
                        }

                        // Add extracted value to telemetryData object if found
                        if (variable) {
                            telemetryData[key] = variable;
                            document.getElementById(key).innerText = key.toUpperCase() + " -> "+variable;
                        }
                    });

                    // Convert telemetryData object to required format for updateCharts and update if data exists
                    if (Object.keys(telemetryData).length > 0) {
                        updateCharts(Object.entries(telemetryData).map(([key, value]) => ({
                            id: key,
                            data: value
                        })));
                    }
                }
                const adcsLine = telemetryLines.find(line => line.includes('A:'));
                const epsLine = telemetryLines.find(line => line.includes('P:'));
                const tcsLine = telemetryLines.find(line => line.includes('T:'));
                if (adcsLine) {
                    const sensorData = adcsLine.split('A:')[1].trim();
                    const sensors = sensorData.split(', ').map(sensor => {
                        const [name, value] = sensor.split('=');
                        return { name: name.trim(), value: parseFloat(value) };
                    });
                    updateADCSDisplay(sensors);
                }
                if (epsLine) {
                    const sensorData = epsLine.split('P:')[1].trim();
                    const sensors = sensorData.split(', ').map(sensor => {
                        const [name, value] = sensor.split('=');
                        return { name: name.trim(), value: parseFloat(value) };
                    });
                    updateEPSDisplay(sensors);
                }
                if (tcsLine) {
                    const sensorData = tcsLine.split('T:')[1].trim();
                    console.log(sensorData);
                    const sensors = sensorData.split(' ').map(sensor => {
                        const [name, value] = sensor.split('=');
                        return { name: name.trim(), value: parseFloat(value) };
                    });
                    updateTCSDisplay(sensors);
                }
                }

            }



        document.getElementById('motorActuate').addEventListener('click', async () => {
            const actuationValue = parseInt(document.getElementById('motorActuation').value);
            if (actuationValue === 0) {
                // Notify user that the motor will not actuate
                Swal.fire({
                    title: "Motor Actuation",
                    text: "The motor will not actuate since the value is 0.",
                    icon: "info",
                    confirmButtonText: "Okay"
                });
            } else if (actuationValue < -5 || actuationValue > 5) {
                // Notify user that the value is out of range
                Swal.fire({
                    title: "Invalid Value",
                    text: "Please select a value between -5 and 5.",
                    icon: "warning",
                    confirmButtonText: "Okay"
                });
            } else {
                // Confirmation dialog
                const result = await Swal.fire({
                    title: "Are you sure?",
                    text: `You are about to actuate the motor with a strength of ${actuationValue}.`,
                    icon: "warning",
                    showCancelButton: true,
                    confirmButtonColor: "#3085d6",
                    cancelButtonColor: "#d33",
                    confirmButtonText: "Confirm."
                });

                if (result.isConfirmed) {
                    // Actuate the motor (implement your actuation logic here)
                    const response = await fetch('/Satellite/SendCommand', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ command: 'aw' + actuationValue }) // Send the 'p21' command
                    });
                    if (response.ok) {
                        Swal.fire({
                            title: "Actuated!",
                            text: `The motor has been actuated - strength ${actuationValue}.`,
                            icon: "success"
                        });
                    }
                }
            }
        });
            document.getElementById('motorActuation').addEventListener('input', (e) => {
                document.getElementById('motorActuationValue').innerText = e.target.value;
            });

            document.addEventListener('DOMContentLoaded', async function () {

                document.getElementById('adcsON').onclick = async function () {
                    try {
                        const response = await fetch('/Satellite/SendCommand', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ command: 'p21' }) // Send the 'p21' command
                        });
                        if (!response.ok) {
                            Swal.fire({
                                position: "top-end",
                                icon: "warning",
                                title: "Command has not been sent",
                                showConfirmButton: false,
                                timer: 1500
                            });
                        } else {
                        var audio = new Audio('./ADCS POWER.mp3');
                        audio.play();

                        Swal.fire({
                            position: "top-end",
                            icon: "success",
                            title: "Command sent successfully",
                            showConfirmButton: false,
                            timer: 1500
                        });
                    }
                    } catch (error) {
                        console.error('Network error:', error);
                    }
                };
            document.getElementById('adcsOFF').onclick = async function () {
                try {
                    const response = await fetch('/Satellite/SendCommand', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ command: 'p20' }) // Send the 'p21' command
                    });
                    if (!response.ok) {
                        Swal.fire({
                            position: "top-end",
                            icon: "warning",
                            title: "Command has not been sent",
                            showConfirmButton: false,
                            timer: 1500
                        });
                    } else {
                        var audio = new Audio('./ADCS OFF.mp3');
                        audio.play();

                        Swal.fire({
                            position: "top-end",
                            icon: "success",
                            title: "Command sent successfully",
                            showConfirmButton: false,
                            timer: 1500
                        });
                    }
                } catch (error) {
                    console.error('Network error:', error);
                }
            };
            document.getElementById('acdsTelemetry').onclick = async function () {
                try {
                    const response = await fetch('/Satellite/SendCommand', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ command: 'da1' }) // Send the 'p21' command
                    });
                    if (!response.ok) {
                        Swal.fire({
                            position: "top-end",
                            icon: "warning",
                            title: "Command has not been sent",
                            showConfirmButton: false,
                            timer: 1500
                        });
                    } else {

                        var audio = new Audio('./ADCS TELEM.mp3');
                        audio.play();

                        Swal.fire({
                            position: "top-end",
                            icon: "success",
                            title: "Command sent successfully",
                            showConfirmButton: false,
                            timer: 1500
                        });
                    }
                } catch (error) {
                    console.error('Network error:', error);
                }
            };
                document.getElementById('epsON').onclick = async function () {
                    try {
                        const response = await fetch('/Satellite/SendCommand', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ command: 'dp1' }) // Send the 'p21' command
                        });
                        if (!response.ok) {
                            Swal.fire({
                                position: "top-end",
                                icon: "warning",
                                title: "Command has not been sent",
                                showConfirmButton: false,
                                timer: 1500
                            });
                        } else {

                        var audio = new Audio('./EPS ON.mp3');
                        audio.play();

                        Swal.fire({
                            position: "top-end",
                            icon: "success",
                            title: "Command sent successfully",
                            showConfirmButton: false,
                            timer: 1500
                        });
                    }
                    } catch (error) {
                        console.error('Network error:', error);
                    }
                };
            document.getElementById('epsOFF').onclick = async function () {
                try {
                    const response = await fetch('/Satellite/SendCommand', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ command: 'dp0' }) // Send the 'p21' command
                    });
                    if (!response.ok) {
                        Swal.fire({
                            position: "top-end",
                            icon: "warning",
                            title: "Command has not been sent",
                            showConfirmButton: false,
                            timer: 1500
                        });
                    } else {
                        
                        var audio = new Audio('./EPS OFF.mp3');
                        audio.play();

                        Swal.fire({
                            position: "top-end",
                            icon: "success",
                            title: "Command sent successfully",
                            showConfirmButton: false,
                            timer: 1500
                        });
                    }
                } catch (error) {
                    console.error('Network error:', error);
                }
            };
            document.getElementById('telemRateBtn').onclick = async function () {
                var interval = document.getElementById("telemRate").value;
                var command = "id" + interval;
                try {
                    const response = await fetch('/Satellite/SendCommand', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ command: command }) // Send the 'p21' command
                    });
                    if (!response.ok) {
                        Swal.fire({
                            position: "top-end",
                            icon: "warning",
                            title: "Command has not been sent",
                            showConfirmButton: false,
                            timer: 1500
                        });
                    } else {
                        Swal.fire({
                            position: "top-end",
                            icon: "success",
                            title: "Command sent successfully",
                            showConfirmButton: false,
                            timer: 1500
                        });
                    }
                } catch (error) {
                    console.error('Network error:', error);
                }
            };
            });
            setInterval(fetchTelemetry, 1000);
            window.onload = fetchTelemetry;

        // Generic update function for any chart
        function updateChart(chartInstance, data) {
            const time = new Date().toLocaleTimeString();
            // Limit the number of data points to 50
            if (chartInstance.data.labels.length >= 50) {
                chartInstance.data.labels.shift();
                chartInstance.data.datasets[0].data.shift();
            }
            chartInstance.data.labels.push('.'); // You can use 'time' instead of '.' if you want actual time on the X-axis
            chartInstance.data.datasets[0].data.push(data);
            chartInstance.update(); // Refresh the chart
        }
        // Define the chart configurations in a list
        const chartsConfig = [
            { id: 'V_SA', label: 'V_SA', color: 'yellow', min: 0, max: 4 },
            { id: 'yaw', label: 'Yaw', color: 'orange', min: 0, max: 400 }
        ];

        // Initialize charts
        const charts = {};
        chartsConfig.forEach(config => {
            //charts[config.id] = initializeChart(config.id, config.label, config.color, config.min, config.max);
        });

        // Update multiple charts dynamically
        function updateCharts(updates) {
            updates.forEach(update => {
                if (charts[update.id]) {
                    updateChart(charts[update.id], update.data);
                }
            });
        }
        function updateADCSDisplay(sensors) {
            const adcsButtons = document.getElementById('adcs-buttons');
    adcsButtons.innerHTML = ''; // Clear any existing buttons

    // Set up a grid layout for the buttons
    adcsButtons.classList.add('grid', 'grid-cols-1', 'gap-2', 'p-2'); // Tailwind classes for grid layout
            sensors.forEach(sensor => {
                const button = document.createElement('button');
                button.classList.add('bg-gray-800', 'text-white', 'py-2', 'px-4', 'rounded', 'sensor-button', 'w-full', 'hover:bg-gray-500');
                button.style.minWidth = '10px';
                button.innerText = `${sensor.name}: ${sensor.value}`;

                // Attach event handler to each button to show the configuration popup
                button.onclick = () => {
                    const chartSensor = sensor.name;

                    if (charts[chartSensor]) {

                        // If chart exists, remove it without showing the pop-up
                        console.log(`Removing existing chart for ${chartSensor}.`);
                        charts[chartSensor].destroy();  // Destroy the existing chart instance
                        delete charts[chartSensor];     // Remove it from the charts object
                        document.getElementById(chartSensor).parentElement.remove(); // Remove the chart element from the DOM
                    } else {
                        currentSensorIdForChart = sensor.name; // Set the current sensor ID
                        currentChartSection = "adcs";
                        chartConfigOverlay.style.display = "flex";
                    }
                };

                // Add button to the display
                adcsButtons.appendChild(button);
            });

}
        function updateEPSDisplay(sensors) {
            const epsButtons = document.getElementById('eps-buttons');
            epsButtons.innerHTML = ''; // Clear any existing buttons

            // Set up a grid layout for the buttons
            epsButtons.classList.add('grid', 'grid-cols-1', 'gap-2', 'p-2');
            sensors.forEach(sensor => {
                const button = document.createElement('button');
                button.classList.add('bg-gray-800', 'text-white', 'py-2', 'px-4', 'rounded', 'sensor-button', 'w-full', 'hover:bg-gray-500');
                button.style.minWidth = '10px';
                button.innerText = `${sensor.name}: ${sensor.value}`;

                // Attach event handler to each button to show the configuration popup
                button.onclick = () => {
                    const chartSensor = sensor.name;

                    if (charts[chartSensor]) {

                        // If chart exists, remove it without showing the pop-up
                        console.log(`Removing existing chart for ${chartSensor}.`);
                        charts[chartSensor].destroy();  // Destroy the existing chart instance
                        delete charts[chartSensor];     // Remove it from the charts object
                        document.getElementById(chartSensor).parentElement.remove(); // Remove the chart element from the DOM
                    } else {
                        currentSensorIdForChart = sensor.name; // Set the current sensor ID
                                currentChartSection = "eps";
                        chartConfigOverlay.style.display = "flex";
                    }
                };

                // Add button to the display
                epsButtons.appendChild(button);
            });
        }

        function updateTCSDisplay(sensors) {
            const epsButtons = document.getElementById('tcs-buttons');
            epsButtons.innerHTML = ''; // Clear any existing buttons

            // Set up a grid layout for the buttons
            epsButtons.classList.add('grid', 'grid-cols-1', 'gap-2', 'p-2');
            sensors.forEach(sensor => {
                const button = document.createElement('button');
                button.classList.add('bg-gray-800', 'text-white', 'py-2', 'px-4', 'rounded', 'sensor-button', 'w-full', 'hover:bg-gray-500');
                button.style.minWidth = '10px';
                button.innerText = `${sensor.name}: ${sensor.value}`;

                // Attach event handler to each button to show the configuration popup
                button.onclick = () => {
                    const chartSensor = sensor.name;

                    if (charts[chartSensor]) {

                        // If chart exists, remove it without showing the pop-up
                        console.log(`Removing existing chart for ${chartSensor}.`);
                        charts[chartSensor].destroy();  // Destroy the existing chart instance
                        delete charts[chartSensor];     // Remove it from the charts object
                        document.getElementById(chartSensor).parentElement.remove(); // Remove the chart element from the DOM
                    } else {
                        currentSensorIdForChart = sensor.name; // Set the current sensor ID
                        currentChartSection = "eps";
                        chartConfigOverlay.style.display = "flex";
                    }
                };

                // Add button to the display
                epsButtons.appendChild(button);
            });
        }

        document.getElementById("toggleReal").addEventListener("click", function () {
            real = !real;
            const status = real ? "Real" : "Fake";
            document.getElementById("status").innerText = "Current Mode: " + status;
        });

        </script>

    </body>

</html>



